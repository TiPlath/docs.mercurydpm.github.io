<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MercuryDPM: Writing Functions Taking Eigen Types as Parameters</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../MDPM.css" rel="stylesheet" type="text/css"/>
<link href="../../codeLabels.css" rel="stylesheet" type="text/css"/>
<link href="../../MDPM-fork-corner.css" rel="stylesheet" type="text/css"/>
<link href="../../MDPM-dropdown-version.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../MDPM-fragment-copy-button.js"></script>
<script type="text/javascript">
DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="../../MDPM-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="../../MDPM-interactive-toc.js"></script>
<script type="text/javascript">
DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="../../MDPM-darkmode-toggle.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
  <div id="bitbucket-corner">
   <a href="https://bitbucket.org/mercurydpm/mercurydpm/src/master/" target="_blank" id="fork-corner" class="fork-corner fc-pos-tr fc-animate fc-theme-bitbucket"></a>
  </div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../mercury-logo-chosen-light-slogan.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> <!--MercuryDPM--!>
   <!-- BEGIN version select -->
   <div class="dropdown" id="projectnumber">
    <button class="dropbtn">v1.0</button>
    <div class="dropdown-content">
    </div>
   </div>
   <script type="text/javascript" src="../../MDPM-dropdown-version.js"></script>
<!-- END version select -->
   <!--&#160;<span id="projectnumber">revision: v1.0</span>-->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<script type="text/javascript" src="../../MDPM-fork-corner.js"></script>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d4/d45/TopicFunctionTakingEigenTypes.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Writing Functions Taking Eigen Types as Parameters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Eigen's use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type Matrix, your expression will implicitly be evaluated into a temporary Matrix, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks: </p><ul>
<li>The evaluation into a temporary may be useless and inefficient; </li>
<li>This only allows the function to read from the expression, not to write to it.</li>
</ul>
<p>Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen's expression templates.</p>
<p>\eigenAutoToc</p>
<h1><a class="anchor" id="TopicFirstExamples"></a>
Some First Examples</h1>
<p>This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also <a class="el" href="../../dd/d50/TopicClassHierarchy.html">The class hierarchy</a>).</p>
<ul>
<li>MatrixBase: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. </li>
<li>ArrayBase: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. </li>
<li>DenseBase: The common base class for all dense matrix expression, that is, the base class for both <code>MatrixBase</code> and <code>ArrayBase</code>. It can be used in functions that are meant to work on both matrices and arrays. </li>
<li>EigenBase: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.</li>
</ul>
<p><b> EigenBase Example </b><br  />
<br  />
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d1/dcc/function__taking__eigenbase_8cpp.html#a38353de07a20cfb289bcd8fed5fbda19">print_size</a>(<span class="keyword">const</span> <a class="code" href="../../d0/d57/structEigen_1_1EigenBase.html">Eigen::EigenBase&lt;Derived&gt;</a>&amp; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;size (rows, cols): &quot;</span> &lt;&lt; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>.size() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>.rows() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>.cols() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d9/d18/T__protectiveWall_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  Eigen::Vector3f <a class="code" href="../../dc/d69/Array__initializer__list__vector__cxx11_8cpp.html#a32398b762ddd48fa3a6d504de68009f9">v</a>;</div>
<div class="line">  <a class="code" href="../../d1/dcc/function__taking__eigenbase_8cpp.html#a38353de07a20cfb289bcd8fed5fbda19">print_size</a>(<a class="code" href="../../dc/d69/Array__initializer__list__vector__cxx11_8cpp.html#a32398b762ddd48fa3a6d504de68009f9">v</a>);</div>
<div class="line">  <span class="comment">// v.asDiagonal() returns a 3x3 diagonal matrix pseudo-expression</span></div>
<div class="line">  <a class="code" href="../../d1/dcc/function__taking__eigenbase_8cpp.html#a38353de07a20cfb289bcd8fed5fbda19">print_size</a>(<a class="code" href="../../dc/d69/Array__initializer__list__vector__cxx11_8cpp.html#a32398b762ddd48fa3a6d504de68009f9">v</a>.asDiagonal());</div>
<div class="line">}</div>
<div class="ttc" id="aArray__initializer__list__vector__cxx11_8cpp_html_a32398b762ddd48fa3a6d504de68009f9"><div class="ttname"><a href="../../dc/d69/Array__initializer__list__vector__cxx11_8cpp.html#a32398b762ddd48fa3a6d504de68009f9">v</a></div><div class="ttdeci">Array&lt; int, Dynamic, 1 &gt; v</div><div class="ttdef"><b>Definition:</b> Array_initializer_list_vector_cxx11.cpp:1</div></div>
<div class="ttc" id="aT__protectiveWall_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="../../d9/d18/T__protectiveWall_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> T_protectiveWall.cpp:194</div></div>
<div class="ttc" id="abenchVecAdd_8cpp_html_af9816f50f32fc22762a8289c3cc44f22"><div class="ttname"><a href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a></div><div class="ttdeci">Scalar * b</div><div class="ttdef"><b>Definition:</b> benchVecAdd.cpp:17</div></div>
<div class="ttc" id="afunction__taking__eigenbase_8cpp_html_a38353de07a20cfb289bcd8fed5fbda19"><div class="ttname"><a href="../../d1/dcc/function__taking__eigenbase_8cpp.html#a38353de07a20cfb289bcd8fed5fbda19">print_size</a></div><div class="ttdeci">void print_size(const Eigen::EigenBase&lt; Derived &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> function_taking_eigenbase.cpp:5</div></div>
<div class="ttc" id="astructEigen_1_1EigenBase_html"><div class="ttname"><a href="../../d0/d57/structEigen_1_1EigenBase.html">Eigen::EigenBase</a></div><div class="ttdef"><b>Definition:</b> EigenBase.h:33</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment"></pre> </td></tr>
</table>
<p><b> DenseBase Example </b><br  />
<br  />
 Prints a sub-block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as DiagonalMatrix. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keywordtype">void</span> print_block(<span class="keyword">const</span> DenseBase&lt;Derived&gt;&amp; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>, <span class="keywordtype">int</span> <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keywordtype">int</span> <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, <span class="keywordtype">int</span> <a class="code" href="../../de/d6c/namespaceUniformPSDSelfTest.html#a9ef26be0d5673c9bb0c2bb8bce5229d8">r</a>, <span class="keywordtype">int</span> <a class="code" href="../../d9/d33/namespacecalibrate.html#a1919e193275bfcb62d1e5b79a3aea213">c</a>)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;block: &quot;</span> &lt;&lt; <a class="code" href="../../db/ddc/benchVecAdd_8cpp.html#af9816f50f32fc22762a8289c3cc44f22">b</a>.block(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>,<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>,<a class="code" href="../../de/d6c/namespaceUniformPSDSelfTest.html#a9ef26be0d5673c9bb0c2bb8bce5229d8">r</a>,<a class="code" href="../../d9/d33/namespacecalibrate.html#a1919e193275bfcb62d1e5b79a3aea213">c</a>) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="alevel1__cplx__impl_8h_html_a068041cb6b3b60d76ee64be754bedcbe"><div class="ttname"><a href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a></div><div class="ttdeci">Scalar * y</div><div class="ttdef"><b>Definition:</b> level1_cplx_impl.h:128</div></div>
<div class="ttc" id="anamespaceUniformPSDSelfTest_html_a9ef26be0d5673c9bb0c2bb8bce5229d8"><div class="ttname"><a href="../../de/d6c/namespaceUniformPSDSelfTest.html#a9ef26be0d5673c9bb0c2bb8bce5229d8">UniformPSDSelfTest.r</a></div><div class="ttdeci">r</div><div class="ttdef"><b>Definition:</b> UniformPSDSelfTest.py:20</div></div>
<div class="ttc" id="anamespacecalibrate_html_a1919e193275bfcb62d1e5b79a3aea213"><div class="ttname"><a href="../../d9/d33/namespacecalibrate.html#a1919e193275bfcb62d1e5b79a3aea213">calibrate.c</a></div><div class="ttdeci">int c</div><div class="ttdef"><b>Definition:</b> calibrate.py:100</div></div>
<div class="ttc" id="anamespaceplotDoE_html_a4758fc6194247f040938f29c863d21ee"><div class="ttname"><a href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">plotDoE.x</a></div><div class="ttdeci">list x</div><div class="ttdef"><b>Definition:</b> plotDoE.py:28</div></div>
</div><!-- fragment --><p> <b> ArrayBase Example </b><br  />
<br  />
 Prints the maximum coefficient of the array or array-expression. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keywordtype">void</span> print_max_coeff(<span class="keyword">const</span> ArrayBase&lt;Derived&gt; &amp;<a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;max: &quot;</span> &lt;&lt; <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>.maxCoeff() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="alevel2__cplx__impl_8h_html_a3c00523890f1892f53e8246b909e04dc"><div class="ttname"><a href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a></div><div class="ttdeci">const Scalar * a</div><div class="ttdef"><b>Definition:</b> level2_cplx_impl.h:32</div></div>
</div><!-- fragment --><p> <b> MatrixBase Example </b><br  />
<br  />
 Prints the inverse condition number of the given matrix or matrix-expression. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keywordtype">void</span> print_inv_cond(<span class="keyword">const</span> MatrixBase&lt;Derived&gt;&amp; <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="../../df/dc8/classEigen_1_1JacobiSVD.html#a21904ae1af9be1313c1b6b199961f18c">JacobiSVD&lt;typename Derived::PlainObject&gt;::SingularValuesType</a>&amp;</div>
<div class="line">    sing_vals = <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>.jacobiSvd().singularValues();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;inv cond: &quot;</span> &lt;&lt; sing_vals(sing_vals.size()-1) / sing_vals(0) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEigen_1_1JacobiSVD_html_a21904ae1af9be1313c1b6b199961f18c"><div class="ttname"><a href="../../df/dc8/classEigen_1_1JacobiSVD.html#a21904ae1af9be1313c1b6b199961f18c">Eigen::JacobiSVD::SingularValuesType</a></div><div class="ttdeci">Base::SingularValuesType SingularValuesType</div><div class="ttdef"><b>Definition:</b> JacobiSVD.h:521</div></div>
</div><!-- fragment --><p> <b> Multiple templated arguments example </b><br  />
<br  />
 Calculate the Euclidean distance between two points. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedA,<span class="keyword">typename</span> DerivedB&gt;</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">DerivedA::Scalar</a> squaredist(<span class="keyword">const</span> MatrixBase&lt;DerivedA&gt;&amp; <a class="code" href="../../db/d01/MatrixBase__all_8cpp.html#acdff45bcf8497bafe04b93e4e704c57b">p1</a>,<span class="keyword">const</span> MatrixBase&lt;DerivedB&gt;&amp; p2)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="../../db/d01/MatrixBase__all_8cpp.html#acdff45bcf8497bafe04b93e4e704c57b">p1</a>-p2).squaredNorm();</div>
<div class="line">}</div>
<div class="ttc" id="aMatrixBase__all_8cpp_html_acdff45bcf8497bafe04b93e4e704c57b"><div class="ttname"><a href="../../db/d01/MatrixBase__all_8cpp.html#acdff45bcf8497bafe04b93e4e704c57b">p1</a></div><div class="ttdeci">Vector3f p1</div><div class="ttdef"><b>Definition:</b> MatrixBase_all.cpp:2</div></div>
<div class="ttc" id="abench__gemm_8cpp_html_a052eb942d12b6404aade6fae4b075fb9"><div class="ttname"><a href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a></div><div class="ttdeci">SCALAR Scalar</div><div class="ttdef"><b>Definition:</b> bench_gemm.cpp:45</div></div>
</div><!-- fragment --><p> Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.g., </p><div class="fragment"><div class="line">squaredist(<a class="code" href="../../d3/ddc/Tutorial__ReshapeMat2Vec_8cpp.html#ab9625a9870f2caafab58a03342febdff">v1</a>,2*<a class="code" href="../../d3/ddc/Tutorial__ReshapeMat2Vec_8cpp.html#aadb36892292ac81ba8d5a277e5fdd83d">v2</a>)</div>
<div class="ttc" id="aTutorial__ReshapeMat2Vec_8cpp_html_aadb36892292ac81ba8d5a277e5fdd83d"><div class="ttname"><a href="../../d3/ddc/Tutorial__ReshapeMat2Vec_8cpp.html#aadb36892292ac81ba8d5a277e5fdd83d">v2</a></div><div class="ttdeci">Map&lt; RowVectorXf &gt; v2(M2.data(), M2.size())</div></div>
<div class="ttc" id="aTutorial__ReshapeMat2Vec_8cpp_html_ab9625a9870f2caafab58a03342febdff"><div class="ttname"><a href="../../d3/ddc/Tutorial__ReshapeMat2Vec_8cpp.html#ab9625a9870f2caafab58a03342febdff">v1</a></div><div class="ttdeci">M1&lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;Map&lt; RowVectorXf &gt; v1(M1.data(), M1.size())</div></div>
</div><!-- fragment --><p> where the first argument <code>v1</code> is a vector and the second argument <code>2*v2</code> is an expression. <br  />
<br  />
</p>
<p>These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant Matrix or Array argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation's problems and advantages. For the discussion below, Matrix and Array as well as MatrixBase and ArrayBase can be exchanged and all arguments still hold.</p>
<h1><a class="anchor" id="TopicUsingRefClass"></a>
How to write generic, but non-templated function?</h1>
<p>In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated functions and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a MatrixXf or a block of a MatrixXf. This is exactly the purpose of the Ref class. Here is a simple example:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/SVD&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="../../d5/d82/function__taking__ref_8cpp.html#a3a8e9bef611dc95c074f980b8cddabaf">inv_cond</a>(<span class="keyword">const</span> <a class="code" href="../../d6/dea/classEigen_1_1Ref.html">Eigen::Ref&lt;const Eigen::MatrixXf&gt;</a>&amp; <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>) {</div>
<div class="line">  <span class="keyword">const</span> Eigen::VectorXf sing_vals = <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a3c00523890f1892f53e8246b909e04dc">a</a>.jacobiSvd().singularValues();</div>
<div class="line">  <span class="keywordflow">return</span> sing_vals(sing_vals.size() - 1) / sing_vals(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d9/d18/T__protectiveWall_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  Eigen::MatrixXf <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a> = Eigen::MatrixXf::Random(4, 4);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;matrix m:\n&quot;</span> &lt;&lt; <a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a> &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;inv_cond(m):          &quot;</span> &lt;&lt; <a class="code" href="../../d5/d82/function__taking__ref_8cpp.html#a3a8e9bef611dc95c074f980b8cddabaf">inv_cond</a>(<a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;inv_cond(m(1:3,1:3)): &quot;</span> &lt;&lt; <a class="code" href="../../d5/d82/function__taking__ref_8cpp.html#a3a8e9bef611dc95c074f980b8cddabaf">inv_cond</a>(<a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a>.topLeftCorner(3, 3)) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;inv_cond(m+I):        &quot;</span> &lt;&lt; <a class="code" href="../../d5/d82/function__taking__ref_8cpp.html#a3a8e9bef611dc95c074f980b8cddabaf">inv_cond</a>(<a class="code" href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a> + Eigen::MatrixXf::Identity(4, 4)) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEigen_1_1Ref_html"><div class="ttname"><a href="../../d6/dea/classEigen_1_1Ref.html">Eigen::Ref</a></div><div class="ttdoc">A matrix or vector expression mapping an existing expression.</div><div class="ttdef"><b>Definition:</b> Ref.h:264</div></div>
<div class="ttc" id="afunction__taking__ref_8cpp_html_a3a8e9bef611dc95c074f980b8cddabaf"><div class="ttname"><a href="../../d5/d82/function__taking__ref_8cpp.html#a3a8e9bef611dc95c074f980b8cddabaf">inv_cond</a></div><div class="ttdeci">float inv_cond(const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;a)</div><div class="ttdef"><b>Definition:</b> function_taking_ref.cpp:4</div></div>
<div class="ttc" id="alevel2__cplx__impl_8h_html_a8d334fd8388055a029936c59d361ff00"><div class="ttname"><a href="../../da/dc6/level2__cplx__impl_8h.html#a8d334fd8388055a029936c59d361ff00">m</a></div><div class="ttdeci">int * m</div><div class="ttdef"><b>Definition:</b> level2_cplx_impl.h:294</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment"></pre> </td></tr>
</table>
<p>In the first two calls to inv_cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref&lt;MatrixXf&gt;. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary MatrixXf by the Ref&lt;&gt; object.</p>
<p>A Ref object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> cov(<span class="keyword">const</span> Ref&lt;const MatrixXf&gt; <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keyword">const</span> Ref&lt;const MatrixXf&gt; <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, Ref&lt;MatrixXf&gt; <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> num_observations = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rows());</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf x_mean = <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf y_mean = <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.colwise().sum() / num_observations;</div>
<div class="line">  <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = (<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rowwise() - x_mean).<a class="code" href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">transpose</a>() * (<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.rowwise() - y_mean) / num_observations;</div>
<div class="line">}</div>
<div class="ttc" id="aclassoomph_1_1Matrix_html"><div class="ttname"><a href="../../d6/d74/classoomph_1_1Matrix.html">oomph::Matrix</a></div><div class="ttdef"><b>Definition:</b> matrices.h:74</div></div>
<div class="ttc" id="anamespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03_html_a94e5ec94b1558945c4b326a98dd939d8"><div class="ttname"><a href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">anonymous_namespace{skew_symmetric_matrix3.cpp}::transpose</a></div><div class="ttdeci">void transpose()</div><div class="ttdef"><b>Definition:</b> skew_symmetric_matrix3.cpp:135</div></div>
</div><!-- fragment --><p> and here are two examples calling cov without any copy: </p><div class="fragment"><div class="line">MatrixXf <a class="code" href="../../d2/d92/IOFormat_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>, <a class="code" href="../../d0/db0/Tutorial__Map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>, m3</div>
<div class="line">cov(<a class="code" href="../../d2/d92/IOFormat_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>, <a class="code" href="../../d0/db0/Tutorial__Map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>, m3);</div>
<div class="line">cov(<a class="code" href="../../d2/d92/IOFormat_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.leftCols&lt;3&gt;(), <a class="code" href="../../d0/db0/Tutorial__Map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>.leftCols&lt;3&gt;(), m3.topLeftCorner&lt;3,3&gt;());</div>
<div class="ttc" id="aIOFormat_8cpp_html_ade6f22163da3c189aade978b48a8bb74"><div class="ttname"><a href="../../d2/d92/IOFormat_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a></div><div class="ttdeci">Matrix3d m1</div><div class="ttdef"><b>Definition:</b> IOFormat.cpp:2</div></div>
<div class="ttc" id="aTutorial__Map__using_8cpp_html_ab3a01b595d22393ace0d30d5fa299f76"><div class="ttname"><a href="../../d0/db0/Tutorial__Map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a></div><div class="ttdeci">MatrixType m2(n_dims)</div></div>
</div><!-- fragment --><p> The Ref&lt;&gt; class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class Ref documentation for the details.</p>
<h1><a class="anchor" id="TopicPlainFunctionsWorking"></a>
In which cases do functions taking plain Matrix or Array arguments work?</h1>
<p>Without using template functions, and without the Ref class, a naive implementation of the previous cov function might look like this </p><div class="fragment"><div class="line">MatrixXf cov(<span class="keyword">const</span> MatrixXf&amp; <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keyword">const</span> MatrixXf&amp; <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> num_observations = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rows());</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf x_mean = <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf y_mean = <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rowwise() - x_mean).<a class="code" href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">transpose</a>() * (<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.rowwise() - y_mean) / num_observations;</div>
<div class="line">}</div>
</div><!-- fragment --><p> and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? </p><div class="fragment"><div class="line">MatrixXf <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>,<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>,z;</div>
<div class="line">MatrixXf <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = cov(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>,<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>+z);</div>
</div><!-- fragment --><p> In this special case, the example is fine and will be working because both parameters are declared as <em>const</em> references. The compiler creates a temporary and evaluates the expression y+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.</p>
<p><b>Note:</b> Functions taking <em>const</em> references to Matrix (or Array) can process expressions at the cost of temporaries.</p>
<h1><a class="anchor" id="TopicPlainFunctionsFailing"></a>
In which cases do functions taking a plain Matrix or Array argument fail?</h1>
<p>Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-const parameter which allows us to store the result. A first naive implementation might look as follows. </p><div class="fragment"><div class="line"><span class="comment">// Note: This code is flawed!</span></div>
<div class="line"><span class="keywordtype">void</span> cov(<span class="keyword">const</span> MatrixXf&amp; <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keyword">const</span> MatrixXf&amp; <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, MatrixXf&amp; <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> num_observations = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rows());</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf x_mean = <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keyword">const</span> RowVectorXf y_mean = <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.colwise().sum() / num_observations;</div>
<div class="line">  <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = (<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rowwise() - x_mean).<a class="code" href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">transpose</a>() * (<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.rowwise() - y_mean) / num_observations;</div>
<div class="line">}</div>
</div><!-- fragment --><p> When trying to execute the following code </p><div class="fragment"><div class="line">MatrixXf <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = <a class="code" href="../../d8/d71/namespaceoomph_1_1PseudoSolidHelper.html#a4d6244e865fddd406dc8589beb58a654">MatrixXf::Zero</a>(3,6);</div>
<div class="line">cov(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>,<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>.block(0,0,3,3));</div>
<div class="ttc" id="anamespaceoomph_1_1PseudoSolidHelper_html_a4d6244e865fddd406dc8589beb58a654"><div class="ttname"><a href="../../d8/d71/namespaceoomph_1_1PseudoSolidHelper.html#a4d6244e865fddd406dc8589beb58a654">oomph::PseudoSolidHelper::Zero</a></div><div class="ttdeci">double Zero</div><div class="ttdef"><b>Definition:</b> pseudosolid_node_update_elements.cc:35</div></div>
</div><!-- fragment --><p> the compiler will fail, because it is not possible to convert the expression returned by <code>MatrixXf::block()</code> into a non-const <code>MatrixXf&amp;</code>. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended &ndash; we want to write to a temporary object. So how can we overcome this problem?</p>
<p>The solution which is preferred at the moment is based on a little <em>hack</em>. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keywordtype">void</span> cov(<span class="keyword">const</span> MatrixBase&lt;Derived&gt;&amp; <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keyword">const</span> MatrixBase&lt;Derived&gt;&amp; <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, MatrixBase&lt;OtherDerived&gt; <span class="keyword">const</span> &amp; <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Derived::Scalar</a> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d9/dbd/structEigen_1_1internal_1_1plain__row__type.html#a141db513b89c2802a029ccceaecb5c12">internal::plain_row_type&lt;Derived&gt;::type</a> RowVectorType;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a> num_observations = <span class="keyword">static_cast&lt;</span><a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a><span class="keyword">&gt;</span>(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rows());</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> RowVectorType x_mean = <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keyword">const</span> RowVectorType y_mean = <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.colwise().sum() / num_observations;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const_cast&lt;</span> MatrixBase&lt;OtherDerived&gt;&amp; <span class="keyword">&gt;</span>(<a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a3a8dbf45d202c92cb1786477c8315262">C</a>) =</div>
<div class="line">    (<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rowwise() - x_mean).<a class="code" href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">transpose</a>() * (<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.rowwise() - y_mean) / num_observations;</div>
<div class="line">}</div>
<div class="ttc" id="abench__gemm_8cpp_html_a3a8dbf45d202c92cb1786477c8315262"><div class="ttname"><a href="../../d8/d3e/bench__gemm_8cpp.html#a3a8dbf45d202c92cb1786477c8315262">C</a></div><div class="ttdeci">Matrix&lt; Scalar, Dynamic, Dynamic &gt; C</div><div class="ttdef"><b>Definition:</b> bench_gemm.cpp:49</div></div>
<div class="ttc" id="astructEigen_1_1internal_1_1plain__row__type_html_a141db513b89c2802a029ccceaecb5c12"><div class="ttname"><a href="../../d9/dbd/structEigen_1_1internal_1_1plain__row__type.html#a141db513b89c2802a029ccceaecb5c12">Eigen::internal::plain_row_type::type</a></div><div class="ttdeci">std::conditional_t&lt; is_same&lt; typename traits&lt; ExpressionType &gt;::XprKind, MatrixXpr &gt;::value, MatrixRowType, ArrayRowType &gt; type</div><div class="ttdef"><b>Definition:</b> XprHelper.h:768</div></div>
</div><!-- fragment --><p> The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.</p>
<p><b>Note:</b> The const cast hack will only work with templated functions. It will not work with the MatrixXf implementation because it is not possible to cast a Block expression to a Matrix reference!</p>
<h1><a class="anchor" id="TopicResizingInGenericImplementations"></a>
How to resize matrices in generic implementations?</h1>
<p>One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the following code to work </p><div class="fragment"><div class="line">MatrixXf <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a> = MatrixXf::Random(100,3);</div>
<div class="line">MatrixXf <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a> = MatrixXf::Random(100,3);</div>
<div class="line">MatrixXf <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a3a8dbf45d202c92cb1786477c8315262">C</a>;</div>
<div class="line">cov(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>);</div>
</div><!-- fragment --><p> This is not the case anymore, when we are using an implementation taking MatrixBase as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix Block be allowed? It is a reference to a sub-matrix and we definitely don't want to resize that. So how can we incorporate resizing if we cannot resize on MatrixBase? The solution is to resize the derived object as in this implementation. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keywordtype">void</span> cov(<span class="keyword">const</span> MatrixBase&lt;Derived&gt;&amp; <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>, <span class="keyword">const</span> MatrixBase&lt;Derived&gt;&amp; <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>, MatrixBase&lt;OtherDerived&gt; <span class="keyword">const</span> &amp; C_)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Derived::Scalar</a> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d9/dbd/structEigen_1_1internal_1_1plain__row__type.html#a141db513b89c2802a029ccceaecb5c12">internal::plain_row_type&lt;Derived&gt;::type</a> RowVectorType;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a> num_observations = <span class="keyword">static_cast&lt;</span><a class="code" href="../../d8/d3e/bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a><span class="keyword">&gt;</span>(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rows());</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> RowVectorType x_mean = <a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.colwise().sum() / num_observations;</div>
<div class="line">  <span class="keyword">const</span> RowVectorType y_mean = <a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.colwise().sum() / num_observations;</div>
<div class="line"> </div>
<div class="line">  MatrixBase&lt;OtherDerived&gt;&amp; <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = <span class="keyword">const_cast&lt;</span> MatrixBase&lt;OtherDerived&gt;&amp; <span class="keyword">&gt;</span>(C_);</div>
<div class="line">  </div>
<div class="line">  <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a>.derived().resize(<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.cols(),<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.cols()); <span class="comment">// resize the derived object</span></div>
<div class="line">  <a class="code" href="../../d6/d74/classoomph_1_1Matrix.html">C</a> = (<a class="code" href="../../db/d46/namespaceplotDoE.html#a4758fc6194247f040938f29c863d21ee">x</a>.rowwise() - x_mean).<a class="code" href="../../d7/df0/namespaceanonymous__namespace_02skew__symmetric__matrix3_8cpp_03.html#a94e5ec94b1558945c4b326a98dd939d8">transpose</a>() * (<a class="code" href="../../d2/d2e/level1__cplx__impl_8h.html#a068041cb6b3b60d76ee64be754bedcbe">y</a>.rowwise() - y_mean) / num_observations;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-time error (in debug mode only) while passing expressions of the correct size will just work fine.</p>
<p><b>Note:</b> In the above discussion the terms Matrix and Array and MatrixBase and ArrayBase can be exchanged and all arguments still hold.</p>
<h1><a class="anchor" id="TopicSummary"></a>
Summary</h1>
<ul>
<li>To summarize, the implementation of functions taking non-writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to MatrixBase or ArrayBase (so templatize your function).</li>
<li>Functions taking writable (non-const) parameters must take const references and cast away constness within the function body.</li>
<li>Functions that take as parameters MatrixBase (or ArrayBase) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived(). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">MercuryDPM Reference Manual</a></li><li class="navelem"><a class="el" href="../../da/dde/UserManual_Generalities.html">General topics</a></li>
    <li class="footer">Generated on Wed Aug 27 2025 17:05:14 for MercuryDPM by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
